{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport Constants, { ExecutionEnvironment } from 'expo-constants';\nimport * as Linking from 'expo-linking';\nimport { Platform } from 'expo-modules-core';\nimport { dismissAuthSession, openAuthSessionAsync } from 'expo-web-browser';\nimport { AuthRequest } from \"./AuthRequest\";\nimport { CodeChallengeMethod, Prompt, ResponseType } from \"./AuthRequest.types\";\nimport { fetchDiscoveryAsync, resolveDiscoveryAsync } from \"./Discovery\";\nimport { generateHexStringAsync } from \"./PKCE\";\nimport { getQueryParams } from \"./QueryParams\";\nimport sessionUrlProvider from \"./SessionUrlProvider\";\nvar _authLock = false;\nexport function startAsync(options) {\n  var authUrl, returnUrl, startUrl, showInRecents, result, _getQueryParams, params, errorCode;\n\n  return _regeneratorRuntime.async(function startAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          authUrl = options.authUrl;\n\n          if (authUrl) {\n            _context.next = 3;\n            break;\n          }\n\n          throw new Error('No authUrl provided to AuthSession.startAsync. An authUrl is required -- it points to the page where the user will be able to sign in.');\n\n        case 3:\n          if (!_authLock) {\n            _context.next = 6;\n            break;\n          }\n\n          if (__DEV__) {\n            console.warn('Attempted to call AuthSession.startAsync multiple times while already active. Only one AuthSession can be active at any given time.');\n          }\n\n          return _context.abrupt(\"return\", {\n            type: 'locked'\n          });\n\n        case 6:\n          returnUrl = options.returnUrl || sessionUrlProvider.getDefaultReturnUrl();\n          startUrl = sessionUrlProvider.getStartUrl(authUrl, returnUrl, options.projectNameForProxy);\n          showInRecents = options.showInRecents || false;\n          _authLock = true;\n          _context.prev = 10;\n          _context.next = 13;\n          return _regeneratorRuntime.awrap(_openWebBrowserAsync(startUrl, returnUrl, showInRecents));\n\n        case 13:\n          result = _context.sent;\n\n        case 14:\n          _context.prev = 14;\n          _authLock = false;\n          return _context.finish(14);\n\n        case 17:\n          if (result) {\n            _context.next = 19;\n            break;\n          }\n\n          throw new Error('Unexpected missing AuthSession result');\n\n        case 19:\n          if ('url' in result) {\n            _context.next = 25;\n            break;\n          }\n\n          if (!('type' in result)) {\n            _context.next = 24;\n            break;\n          }\n\n          return _context.abrupt(\"return\", result);\n\n        case 24:\n          throw new Error('Unexpected AuthSession result with missing type');\n\n        case 25:\n          _getQueryParams = getQueryParams(result.url), params = _getQueryParams.params, errorCode = _getQueryParams.errorCode;\n          return _context.abrupt(\"return\", {\n            type: errorCode ? 'error' : 'success',\n            params: params,\n            errorCode: errorCode,\n            authentication: null,\n            url: result.url\n          });\n\n        case 27:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[10,, 14, 17]], Promise);\n}\nexport function dismiss() {\n  dismissAuthSession();\n}\nexport var getDefaultReturnUrl = sessionUrlProvider.getDefaultReturnUrl;\nexport function getRedirectUrl(path) {\n  return sessionUrlProvider.getRedirectUrl({\n    urlPath: path\n  });\n}\nexport function makeRedirectUri() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      native = _ref.native,\n      scheme = _ref.scheme,\n      isTripleSlashed = _ref.isTripleSlashed,\n      queryParams = _ref.queryParams,\n      path = _ref.path,\n      preferLocalhost = _ref.preferLocalhost,\n      useProxy = _ref.useProxy,\n      projectNameForProxy = _ref.projectNameForProxy;\n\n  if (Platform.OS !== 'web' && native && [ExecutionEnvironment.Standalone, ExecutionEnvironment.Bare].includes(Constants.executionEnvironment)) {\n    return native;\n  }\n\n  if (!useProxy || Platform.OS === 'web') {\n    var url = Linking.createURL(path || '', {\n      isTripleSlashed: isTripleSlashed,\n      scheme: scheme,\n      queryParams: queryParams\n    });\n\n    if (preferLocalhost) {\n      var ipAddress = url.match(/\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b/);\n\n      if (ipAddress != null && ipAddress.length) {\n        var _url$split = url.split(ipAddress[0]),\n            _url$split2 = _slicedToArray(_url$split, 2),\n            protocol = _url$split2[0],\n            _path = _url$split2[1];\n\n        return protocol + \"localhost\" + _path;\n      }\n    }\n\n    return url;\n  }\n\n  return sessionUrlProvider.getRedirectUrl({\n    urlPath: path,\n    projectNameForProxy: projectNameForProxy\n  });\n}\nexport function loadAsync(config, issuerOrDiscovery) {\n  var request, discovery;\n  return _regeneratorRuntime.async(function loadAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          request = new AuthRequest(config);\n          _context2.next = 3;\n          return _regeneratorRuntime.awrap(resolveDiscoveryAsync(issuerOrDiscovery));\n\n        case 3:\n          discovery = _context2.sent;\n          _context2.next = 6;\n          return _regeneratorRuntime.awrap(request.makeAuthUrlAsync(discovery));\n\n        case 6:\n          return _context2.abrupt(\"return\", request);\n\n        case 7:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction _openWebBrowserAsync(startUrl, returnUrl, showInRecents) {\n  var result;\n  return _regeneratorRuntime.async(function _openWebBrowserAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return _regeneratorRuntime.awrap(openAuthSessionAsync(startUrl, returnUrl, {\n            showInRecents: showInRecents\n          }));\n\n        case 2:\n          result = _context3.sent;\n\n          if (!(result.type === 'cancel' || result.type === 'dismiss')) {\n            _context3.next = 5;\n            break;\n          }\n\n          return _context3.abrupt(\"return\", {\n            type: result.type\n          });\n\n        case 5:\n          return _context3.abrupt(\"return\", result);\n\n        case 6:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nexport { useAutoDiscovery, useAuthRequest } from \"./AuthRequestHooks\";\nexport { AuthError, TokenError } from \"./Errors\";\nexport { AuthRequest, CodeChallengeMethod, Prompt, ResponseType, resolveDiscoveryAsync, fetchDiscoveryAsync, generateHexStringAsync };\nexport { TokenResponse, AccessTokenRequest, RefreshTokenRequest, RevokeTokenRequest, revokeAsync, refreshAsync, exchangeCodeAsync, fetchUserInfoAsync } from \"./TokenRequest\";\nexport * from \"./TokenRequest.types\";","map":{"version":3,"sources":["../src/AuthSession.ts"],"names":[],"mappings":"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","sourcesContent":["import Constants, { ExecutionEnvironment } from 'expo-constants';\nimport * as Linking from 'expo-linking';\nimport { Platform } from 'expo-modules-core';\nimport {\n  dismissAuthSession,\n  openAuthSessionAsync,\n  WebBrowserAuthSessionResult,\n} from 'expo-web-browser';\n\nimport { AuthRequest } from './AuthRequest';\nimport {\n  AuthRequestConfig,\n  AuthRequestPromptOptions,\n  CodeChallengeMethod,\n  Prompt,\n  ResponseType,\n} from './AuthRequest.types';\nimport {\n  AuthSessionOptions,\n  AuthSessionRedirectUriOptions,\n  AuthSessionResult,\n} from './AuthSession.types';\nimport {\n  DiscoveryDocument,\n  fetchDiscoveryAsync,\n  Issuer,\n  IssuerOrDiscovery,\n  ProviderMetadata,\n  resolveDiscoveryAsync,\n} from './Discovery';\nimport { generateHexStringAsync } from './PKCE';\nimport { getQueryParams } from './QueryParams';\nimport sessionUrlProvider from './SessionUrlProvider';\n\nlet _authLock = false;\n\n// @needsAudit\n/**\n * Initiate a proxied authentication session with the given options. Only one `AuthSession` can be active at any given time in your application.\n * If you attempt to open a second session while one is still in progress, the second session will return a value to indicate that `AuthSession` is locked.\n *\n * @param options An object of type `AuthSessionOptions`.\n * @return Returns a Promise that resolves to an `AuthSessionResult` object.\n */\nexport async function startAsync(options: AuthSessionOptions): Promise<AuthSessionResult> {\n  const authUrl = options.authUrl;\n  // Prevent accidentally starting to an empty url\n  if (!authUrl) {\n    throw new Error(\n      'No authUrl provided to AuthSession.startAsync. An authUrl is required -- it points to the page where the user will be able to sign in.'\n    );\n  }\n  // Prevent multiple sessions from running at the same time, WebBrowser doesn't\n  // support it this makes the behavior predictable.\n  if (_authLock) {\n    if (__DEV__) {\n      console.warn(\n        'Attempted to call AuthSession.startAsync multiple times while already active. Only one AuthSession can be active at any given time.'\n      );\n    }\n\n    return { type: 'locked' };\n  }\n\n  const returnUrl = options.returnUrl || sessionUrlProvider.getDefaultReturnUrl();\n  const startUrl = sessionUrlProvider.getStartUrl(authUrl, returnUrl, options.projectNameForProxy);\n  const showInRecents = options.showInRecents || false;\n\n  // About to start session, set lock\n  _authLock = true;\n\n  let result: WebBrowserAuthSessionResult;\n  try {\n    result = await _openWebBrowserAsync(startUrl, returnUrl, showInRecents);\n  } finally {\n    // WebBrowser session complete, unset lock\n    _authLock = false;\n  }\n\n  // Handle failures\n  if (!result) {\n    throw new Error('Unexpected missing AuthSession result');\n  }\n  if (!('url' in result)) {\n    if ('type' in result) {\n      return result;\n    } else {\n      throw new Error('Unexpected AuthSession result with missing type');\n    }\n  }\n\n  const { params, errorCode } = getQueryParams(result.url);\n\n  return {\n    type: errorCode ? 'error' : 'success',\n    params,\n    errorCode,\n    authentication: null,\n    url: result.url,\n  };\n}\n\n// @needsAudit\n/**\n * Cancels an active `AuthSession` if there is one. No return value, but if there is an active `AuthSession`\n * then the Promise returned by the `AuthSession.startAsync()` that initiated it resolves to `{ type: 'dismiss' }`.\n */\nexport function dismiss() {\n  dismissAuthSession();\n}\n\nexport const getDefaultReturnUrl = sessionUrlProvider.getDefaultReturnUrl;\n\n// @needsAudit @docsMissing\n/**\n * Get the URL that your authentication provider needs to redirect to. For example: `https://auth.expo.io/@your-username/your-app-slug`. You can pass an additional path component to be appended to the default redirect URL.\n * > **Note** This method will throw an exception if you're using the bare workflow on native.\n *\n * @param path\n * @return\n *\n * @example\n * ```ts\n * const url = AuthSession.getRedirectUrl('redirect');\n *\n * // Managed: https://auth.expo.io/@your-username/your-app-slug/redirect\n * // Web: https://localhost:19006/redirect\n * ```\n *\n * @deprecated Use `makeRedirectUri({ path, useProxy })` instead.\n */\nexport function getRedirectUrl(path?: string): string {\n  return sessionUrlProvider.getRedirectUrl({ urlPath: path });\n}\n\n// @needsAudit\n/**\n * Create a redirect url for the current platform and environment. You need to manually define the redirect that will be used in\n * a bare workflow React Native app, or an Expo standalone app, this is because it cannot be inferred automatically.\n * - **Web:** Generates a path based on the current `window.location`. For production web apps, you should hard code the URL as well.\n * - **Managed workflow:** Uses the `scheme` property of your `app.config.js` or `app.json`.\n *   - **Proxy:** Uses `auth.expo.io` as the base URL for the path. This only works in Expo Go and standalone environments.\n * - **Bare workflow:** Will fallback to using the `native` option for bare workflow React Native apps.\n *\n * @param options Additional options for configuring the path.\n * @return The `redirectUri` to use in an authentication request.\n *\n * @example\n * ```ts\n * const redirectUri = makeRedirectUri({\n *   scheme: 'my-scheme',\n *   path: 'redirect'\n * });\n * // Custom app: my-scheme://redirect\n * // Expo Go: exp://127.0.0.1:19000/--/redirect\n * // Web dev: https://localhost:19006/redirect\n * // Web prod: https://yourwebsite.com/redirect\n *\n * const redirectUri2 = makeRedirectUri({\n *   scheme: 'scheme2',\n *   preferLocalhost: true,\n *   isTripleSlashed: true,\n * });\n * // Custom app: scheme2:///\n * // Expo Go: exp://localhost:19000\n * // Web dev: https://localhost:19006\n * // Web prod: https://yourwebsite.com\n *\n * const redirectUri3 = makeRedirectUri({\n *   useProxy: true,\n * });\n * // Custom app: https://auth.expo.io/@username/slug\n * // Expo Go: https://auth.expo.io/@username/slug\n * // Web dev: https://localhost:19006\n * // Web prod: https://yourwebsite.com\n * ```\n */\nexport function makeRedirectUri({\n  native,\n  scheme,\n  isTripleSlashed,\n  queryParams,\n  path,\n  preferLocalhost,\n  useProxy,\n  projectNameForProxy,\n}: AuthSessionRedirectUriOptions = {}): string {\n  if (\n    Platform.OS !== 'web' &&\n    native &&\n    [ExecutionEnvironment.Standalone, ExecutionEnvironment.Bare].includes(\n      Constants.executionEnvironment\n    )\n  ) {\n    // Should use the user-defined native scheme in standalone builds\n    return native;\n  }\n  if (!useProxy || Platform.OS === 'web') {\n    const url = Linking.createURL(path || '', {\n      isTripleSlashed,\n      scheme,\n      queryParams,\n    });\n\n    if (preferLocalhost) {\n      const ipAddress = url.match(\n        /\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b/\n      );\n      // Only replace if an IP address exists\n      if (ipAddress?.length) {\n        const [protocol, path] = url.split(ipAddress[0]);\n        return `${protocol}localhost${path}`;\n      }\n    }\n\n    return url;\n  }\n  // Attempt to use the proxy\n  return sessionUrlProvider.getRedirectUrl({ urlPath: path, projectNameForProxy });\n}\n\n// @needsAudit\n/**\n * Build an `AuthRequest` and load it before returning.\n *\n * @param config A valid [`AuthRequestConfig`](#authrequestconfig) that specifies what provider to use.\n * @param issuerOrDiscovery A loaded [`DiscoveryDocument`](#discoverydocument) or issuer URL.\n * (Only `authorizationEndpoint` is required for requesting an authorization code).\n * @return Returns an instance of `AuthRequest` that can be used to prompt the user for authorization.\n */\nexport async function loadAsync(\n  config: AuthRequestConfig,\n  issuerOrDiscovery: IssuerOrDiscovery\n): Promise<AuthRequest> {\n  const request = new AuthRequest(config);\n  const discovery = await resolveDiscoveryAsync(issuerOrDiscovery);\n  await request.makeAuthUrlAsync(discovery);\n  return request;\n}\n\nasync function _openWebBrowserAsync(startUrl: string, returnUrl: string, showInRecents: boolean) {\n  const result = await openAuthSessionAsync(startUrl, returnUrl, { showInRecents });\n  if (result.type === 'cancel' || result.type === 'dismiss') {\n    return { type: result.type };\n  }\n\n  return result;\n}\n\nexport { useAutoDiscovery, useAuthRequest } from './AuthRequestHooks';\nexport { AuthError, TokenError } from './Errors';\n\nexport {\n  AuthSessionOptions,\n  AuthSessionRedirectUriOptions,\n  AuthSessionResult,\n  AuthRequest,\n  AuthRequestConfig,\n  AuthRequestPromptOptions,\n  CodeChallengeMethod,\n  DiscoveryDocument,\n  Issuer,\n  IssuerOrDiscovery,\n  Prompt,\n  ProviderMetadata,\n  ResponseType,\n  resolveDiscoveryAsync,\n  fetchDiscoveryAsync,\n  generateHexStringAsync,\n};\n\nexport {\n  // Token classes\n  TokenResponse,\n  AccessTokenRequest,\n  RefreshTokenRequest,\n  RevokeTokenRequest,\n  // Token methods\n  revokeAsync,\n  refreshAsync,\n  exchangeCodeAsync,\n  fetchUserInfoAsync,\n} from './TokenRequest';\n\n// Token types\nexport * from './TokenRequest.types';\n\n// Provider specific types\nexport { GoogleAuthRequestConfig } from './providers/Google';\nexport { FacebookAuthRequestConfig } from './providers/Facebook';\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
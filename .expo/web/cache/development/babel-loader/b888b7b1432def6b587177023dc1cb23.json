{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport * as Crypto from 'expo-crypto';\nimport * as Random from 'expo-random';\nimport invariant from 'invariant';\nvar CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\nfunction getRandomValues(input) {\n  var output = input;\n  if (input.byteLength !== input.length) input = new Uint8Array(input.buffer);\n  var bytes = Random.getRandomBytes(input.length);\n\n  for (var i = 0; i < bytes.length; i++) {\n    input[i] = bytes[i];\n  }\n\n  return output;\n}\n\nfunction convertBufferToString(buffer) {\n  var state = [];\n\n  for (var i = 0; i < buffer.byteLength; i += 1) {\n    var index = buffer[i] % CHARSET.length;\n    state.push(CHARSET[index]);\n  }\n\n  return state.join('');\n}\n\nfunction convertToUrlSafeString(b64) {\n  return b64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nexport function generateRandom(size) {\n  var buffer = new Uint8Array(size);\n  getRandomValues(buffer);\n  return convertBufferToString(buffer);\n}\nexport function deriveChallengeAsync(code) {\n  var buffer;\n  return _regeneratorRuntime.async(function deriveChallengeAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          invariant(code.length > 42 && code.length < 129, 'Invalid code length for PKCE.');\n          _context.next = 3;\n          return _regeneratorRuntime.awrap(Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, code, {\n            encoding: Crypto.CryptoEncoding.BASE64\n          }));\n\n        case 3:\n          buffer = _context.sent;\n          return _context.abrupt(\"return\", convertToUrlSafeString(buffer));\n\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function buildCodeAsync() {\n  var size,\n      codeVerifier,\n      codeChallenge,\n      _args2 = arguments;\n  return _regeneratorRuntime.async(function buildCodeAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          size = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : 128;\n          codeVerifier = generateRandom(size);\n          _context2.next = 4;\n          return _regeneratorRuntime.awrap(deriveChallengeAsync(codeVerifier));\n\n        case 4:\n          codeChallenge = _context2.sent;\n          return _context2.abrupt(\"return\", {\n            codeVerifier: codeVerifier,\n            codeChallenge: codeChallenge\n          });\n\n        case 6:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function generateHexStringAsync(size) {\n  var value, buffer;\n  return _regeneratorRuntime.async(function generateHexStringAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          value = generateRandom(size);\n          _context3.next = 3;\n          return _regeneratorRuntime.awrap(Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, value, {\n            encoding: Crypto.CryptoEncoding.HEX\n          }));\n\n        case 3:\n          buffer = _context3.sent;\n          return _context3.abrupt(\"return\", convertToUrlSafeString(buffer));\n\n        case 5:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}","map":{"version":3,"sources":["../src/PKCE.ts"],"names":[],"mappings":"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","sourcesContent":["import * as Crypto from 'expo-crypto';\nimport * as Random from 'expo-random';\nimport invariant from 'invariant';\n\nconst CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\nfunction getRandomValues(input: Uint8Array): Uint8Array {\n  const output = input;\n  // Get access to the underlying raw bytes\n  if (input.byteLength !== input.length) input = new Uint8Array(input.buffer);\n\n  const bytes = Random.getRandomBytes(input.length);\n\n  for (let i = 0; i < bytes.length; i++) input[i] = bytes[i];\n\n  return output;\n}\n\nfunction convertBufferToString(buffer: Uint8Array): string {\n  const state: string[] = [];\n  for (let i = 0; i < buffer.byteLength; i += 1) {\n    const index = buffer[i] % CHARSET.length;\n    state.push(CHARSET[index]);\n  }\n  return state.join('');\n}\n\nfunction convertToUrlSafeString(b64: string): string {\n  return b64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nexport function generateRandom(size: number): string {\n  const buffer = new Uint8Array(size);\n  getRandomValues(buffer);\n  return convertBufferToString(buffer);\n}\n\n/**\n * Proof key for Code Exchange by OAuth Public Clients (RFC 7636), Section 4.1\n * [Section 4.1](https://tools.ietf.org/html/rfc7636#section-4.1)\n */\nexport async function deriveChallengeAsync(code: string): Promise<string> {\n  // 43 is the minimum, and 128 is the maximum.\n  invariant(code.length > 42 && code.length < 129, 'Invalid code length for PKCE.');\n\n  const buffer = await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, code, {\n    encoding: Crypto.CryptoEncoding.BASE64,\n  });\n  return convertToUrlSafeString(buffer);\n}\n\nexport async function buildCodeAsync(\n  size: number = 128\n): Promise<{ codeChallenge: string; codeVerifier: string }> {\n  // This method needs to be resolved like all other native methods.\n  const codeVerifier = generateRandom(size);\n  const codeChallenge = await deriveChallengeAsync(codeVerifier);\n\n  return { codeVerifier, codeChallenge };\n}\n\n/**\n * Digest a random string with hex encoding, useful for creating `nonce`s.\n */\nexport async function generateHexStringAsync(size: number): Promise<string> {\n  const value = generateRandom(size);\n  const buffer = await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, value, {\n    encoding: Crypto.CryptoEncoding.HEX,\n  });\n  return convertToUrlSafeString(buffer);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nvar _excluded = [\"windowFeatures\"];\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport { useCallback, useMemo, useEffect, useState } from 'react';\nimport { AuthRequest } from \"./AuthRequest\";\nimport { resolveDiscoveryAsync } from \"./Discovery\";\nexport function useAutoDiscovery(issuerOrDiscovery) {\n  var _useState = useState(null),\n      _useState2 = _slicedToArray(_useState, 2),\n      discovery = _useState2[0],\n      setDiscovery = _useState2[1];\n\n  useEffect(function () {\n    var isAllowed = true;\n    resolveDiscoveryAsync(issuerOrDiscovery).then(function (discovery) {\n      if (isAllowed) {\n        setDiscovery(discovery);\n      }\n    });\n    return function () {\n      isAllowed = false;\n    };\n  }, [issuerOrDiscovery]);\n  return discovery;\n}\nexport function useLoadedAuthRequest(config, discovery, AuthRequestInstance) {\n  var _useState3 = useState(null),\n      _useState4 = _slicedToArray(_useState3, 2),\n      request = _useState4[0],\n      setRequest = _useState4[1];\n\n  var scopeString = useMemo(function () {\n    var _config$scopes;\n\n    return (_config$scopes = config.scopes) == null ? void 0 : _config$scopes.join(',');\n  }, [config.scopes]);\n  var extraParamsString = useMemo(function () {\n    return JSON.stringify(config.extraParams || {});\n  }, [config.extraParams]);\n  useEffect(function () {\n    var isMounted = true;\n\n    if (discovery) {\n      var _request = new AuthRequestInstance(config);\n\n      _request.makeAuthUrlAsync(discovery).then(function () {\n        if (isMounted) {\n          setRequest(_request);\n        }\n      });\n    }\n\n    return function () {\n      isMounted = false;\n    };\n  }, [discovery == null ? void 0 : discovery.authorizationEndpoint, config.clientId, config.redirectUri, config.responseType, config.prompt, config.clientSecret, config.codeChallenge, config.state, config.usePKCE, scopeString, extraParamsString]);\n  return request;\n}\nexport function useAuthRequestResult(request, discovery) {\n  var customOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _useState5 = useState(null),\n      _useState6 = _slicedToArray(_useState5, 2),\n      result = _useState6[0],\n      setResult = _useState6[1];\n\n  var promptAsync = useCallback(function _callee() {\n    var _customOptions$window;\n\n    var _ref,\n        _ref$windowFeatures,\n        windowFeatures,\n        options,\n        inputOptions,\n        result,\n        _args = arguments;\n\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _ref = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n            _ref$windowFeatures = _ref.windowFeatures, windowFeatures = _ref$windowFeatures === void 0 ? {} : _ref$windowFeatures, options = _objectWithoutProperties(_ref, _excluded);\n\n            if (!(!discovery || !request)) {\n              _context.next = 4;\n              break;\n            }\n\n            throw new Error('Cannot prompt to authenticate until the request has finished loading.');\n\n          case 4:\n            inputOptions = _objectSpread(_objectSpread(_objectSpread({}, customOptions), options), {}, {\n              windowFeatures: _objectSpread(_objectSpread({}, (_customOptions$window = customOptions.windowFeatures) != null ? _customOptions$window : {}), windowFeatures)\n            });\n            _context.next = 7;\n            return _regeneratorRuntime.awrap(request == null ? void 0 : request.promptAsync(discovery, inputOptions));\n\n          case 7:\n            result = _context.sent;\n            setResult(result);\n            return _context.abrupt(\"return\", result);\n\n          case 10:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }, [request == null ? void 0 : request.url, discovery == null ? void 0 : discovery.authorizationEndpoint]);\n  return [result, promptAsync];\n}\nexport function useAuthRequest(config, discovery) {\n  var request = useLoadedAuthRequest(config, discovery, AuthRequest);\n\n  var _useAuthRequestResult = useAuthRequestResult(request, discovery),\n      _useAuthRequestResult2 = _slicedToArray(_useAuthRequestResult, 2),\n      result = _useAuthRequestResult2[0],\n      promptAsync = _useAuthRequestResult2[1];\n\n  return [request, result, promptAsync];\n}","map":{"version":3,"sources":["../src/AuthRequestHooks.ts"],"names":[],"mappings":"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","sourcesContent":["import { useCallback, useMemo, useEffect, useState } from 'react';\n\nimport { AuthRequest } from './AuthRequest';\nimport { AuthRequestConfig, AuthRequestPromptOptions } from './AuthRequest.types';\nimport { AuthSessionResult } from './AuthSession.types';\nimport { DiscoveryDocument, IssuerOrDiscovery, resolveDiscoveryAsync } from './Discovery';\n\n// @needsAudit\n/**\n * Given an OpenID Connect issuer URL, this will fetch and return the [`DiscoveryDocument`](#discoverydocument)\n * (a collection of URLs) from the resource provider.\n *\n * @param issuerOrDiscovery URL using the `https` scheme with no query or fragment component that the OP asserts as its Issuer Identifier.\n * @return Returns `null` until the [`DiscoveryDocument`](#discoverydocument) has been fetched from the provided issuer URL.\n *\n * @example\n * ```ts\n * const discovery = useAutoDiscovery('https://example.com/auth');\n * ```\n */\nexport function useAutoDiscovery(issuerOrDiscovery: IssuerOrDiscovery): DiscoveryDocument | null {\n  const [discovery, setDiscovery] = useState<DiscoveryDocument | null>(null);\n\n  useEffect(() => {\n    let isAllowed = true;\n    resolveDiscoveryAsync(issuerOrDiscovery).then((discovery) => {\n      if (isAllowed) {\n        setDiscovery(discovery);\n      }\n    });\n\n    return () => {\n      isAllowed = false;\n    };\n  }, [issuerOrDiscovery]);\n\n  return discovery;\n}\n\nexport function useLoadedAuthRequest(\n  config: AuthRequestConfig,\n  discovery: DiscoveryDocument | null,\n  AuthRequestInstance: typeof AuthRequest\n): AuthRequest | null {\n  const [request, setRequest] = useState<AuthRequest | null>(null);\n  const scopeString = useMemo(() => config.scopes?.join(','), [config.scopes]);\n  const extraParamsString = useMemo(\n    () => JSON.stringify(config.extraParams || {}),\n    [config.extraParams]\n  );\n  useEffect(() => {\n    let isMounted = true;\n\n    if (discovery) {\n      const request = new AuthRequestInstance(config);\n      request.makeAuthUrlAsync(discovery).then(() => {\n        if (isMounted) {\n          setRequest(request);\n        }\n      });\n    }\n    return () => {\n      isMounted = false;\n    };\n  }, [\n    discovery?.authorizationEndpoint,\n    config.clientId,\n    config.redirectUri,\n    config.responseType,\n    config.prompt,\n    config.clientSecret,\n    config.codeChallenge,\n    config.state,\n    config.usePKCE,\n    scopeString,\n    extraParamsString,\n  ]);\n  return request;\n}\n\ntype PromptMethod = (options?: AuthRequestPromptOptions) => Promise<AuthSessionResult>;\n\nexport function useAuthRequestResult(\n  request: AuthRequest | null,\n  discovery: DiscoveryDocument | null,\n  customOptions: AuthRequestPromptOptions = {}\n): [AuthSessionResult | null, PromptMethod] {\n  const [result, setResult] = useState<AuthSessionResult | null>(null);\n\n  const promptAsync = useCallback(\n    async ({ windowFeatures = {}, ...options }: AuthRequestPromptOptions = {}) => {\n      if (!discovery || !request) {\n        throw new Error('Cannot prompt to authenticate until the request has finished loading.');\n      }\n      const inputOptions = {\n        ...customOptions,\n        ...options,\n        windowFeatures: {\n          ...(customOptions.windowFeatures ?? {}),\n          ...windowFeatures,\n        },\n      };\n      const result = await request?.promptAsync(discovery, inputOptions);\n      setResult(result);\n      return result;\n    },\n    [request?.url, discovery?.authorizationEndpoint]\n  );\n\n  return [result, promptAsync];\n}\n\n// @needsAudit\n/**\n * Load an authorization request for a code. When the prompt method completes then the response will be fulfilled.\n *\n * > In order to close the popup window on web, you need to invoke `WebBrowser.maybeCompleteAuthSession()`.\n * > See the [Identity example](/guides/authentication.md#identityserver-4) for more info.\n *\n * If an Implicit grant flow was used, you can pass the `response.params` to `TokenResponse.fromQueryParams()`\n * to get a `TokenResponse` instance which you can use to easily refresh the token.\n *\n * @param config A valid [`AuthRequestConfig`](#authrequestconfig) that specifies what provider to use.\n * @param discovery A loaded [`DiscoveryDocument`](#discoverydocument) with endpoints used for authenticating.\n * Only `authorizationEndpoint` is required for requesting an authorization code.\n *\n * @return Returns a loaded request, a response, and a prompt method in a single array in the following order:\n * - `request` - An instance of [`AuthRequest`](#authrequest) that can be used to prompt the user for authorization.\n *   This will be `null` until the auth request has finished loading.\n * - `response` - This is `null` until `promptAsync` has been invoked. Once fulfilled it will return information about the authorization.\n * - `promptAsync` - When invoked, a web browser will open up and prompt the user for authentication.\n *   Accepts an [`AuthRequestPromptOptions`](#authrequestpromptoptions) object with options about how the prompt will execute.\n *   You can use this to enable the Expo proxy service `auth.expo.io`.\n *\n * @example\n * ```ts\n * const [request, response, promptAsync] = useAuthRequest({ ... }, { ... });\n * ```\n */\nexport function useAuthRequest(\n  config: AuthRequestConfig,\n  discovery: DiscoveryDocument | null\n): [\n  AuthRequest | null,\n  AuthSessionResult | null,\n  (options?: AuthRequestPromptOptions) => Promise<AuthSessionResult>\n] {\n  const request = useLoadedAuthRequest(config, discovery, AuthRequest);\n  const [result, promptAsync] = useAuthRequestResult(request, discovery);\n  return [request, result, promptAsync];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
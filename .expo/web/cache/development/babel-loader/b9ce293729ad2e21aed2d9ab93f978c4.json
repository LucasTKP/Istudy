{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { toByteArray } from 'base64-js';\nimport { UnavailabilityError } from 'expo-modules-core';\nimport ExpoRandom from \"./ExpoRandom\";\n\nfunction assertByteCount(value, methodName) {\n  if (typeof value !== 'number' || isNaN(value) || Math.floor(value) < 0 || Math.floor(value) > 1024) {\n    throw new TypeError(\"expo-random: \" + methodName + \"(\" + value + \") expected a valid number from range 0...1024\");\n  }\n}\n\nexport function getRandomBytes(byteCount) {\n  assertByteCount(byteCount, 'getRandomBytes');\n  var validByteCount = Math.floor(byteCount);\n\n  if (__DEV__) {\n    if (!global.nativeCallSyncHook || global.__REMOTEDEV__) {\n      var array = new Uint8Array(validByteCount);\n\n      for (var i = 0; i < validByteCount; i++) {\n        array[i] = Math.floor(Math.random() * 256);\n      }\n\n      return array;\n    }\n  }\n\n  if (ExpoRandom.getRandomBytes) {\n    return ExpoRandom.getRandomBytes(validByteCount);\n  } else if (ExpoRandom.getRandomBase64String) {\n    var base64 = ExpoRandom.getRandomBase64String(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-random', 'getRandomBytes');\n  }\n}\nexport function getRandomBytesAsync(byteCount) {\n  var validByteCount, base64;\n  return _regeneratorRuntime.async(function getRandomBytesAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          assertByteCount(byteCount, 'getRandomBytesAsync');\n          validByteCount = Math.floor(byteCount);\n\n          if (!ExpoRandom.getRandomBytesAsync) {\n            _context.next = 8;\n            break;\n          }\n\n          _context.next = 5;\n          return _regeneratorRuntime.awrap(ExpoRandom.getRandomBytesAsync(validByteCount));\n\n        case 5:\n          return _context.abrupt(\"return\", _context.sent);\n\n        case 8:\n          if (!ExpoRandom.getRandomBase64StringAsync) {\n            _context.next = 15;\n            break;\n          }\n\n          _context.next = 11;\n          return _regeneratorRuntime.awrap(ExpoRandom.getRandomBase64StringAsync(validByteCount));\n\n        case 11:\n          base64 = _context.sent;\n          return _context.abrupt(\"return\", toByteArray(base64));\n\n        case 15:\n          throw new UnavailabilityError('expo-random', 'getRandomBytesAsync');\n\n        case 16:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}","map":{"version":3,"sources":["../src/Random.ts"],"names":[],"mappings":";AAAA,SAAS,WAAT,QAA4B,WAA5B;AACA,SAAS,mBAAT,QAAoC,mBAApC;AAEA,OAAO,UAAP;;AAEA,SAAS,eAAT,CAAyB,KAAzB,EAAqC,UAArC,EAAuD;EACrD,IACE,OAAO,KAAP,KAAiB,QAAjB,IACA,KAAK,CAAC,KAAD,CADL,IAEA,IAAI,CAAC,KAAL,CAAW,KAAX,IAAoB,CAFpB,IAGA,IAAI,CAAC,KAAL,CAAW,KAAX,IAAoB,IAJtB,EAKE;IACA,MAAM,IAAI,SAAJ,mBACY,UADZ,SAC0B,KAD1B,mDAAN;EAGD;AACF;;AAUD,OAAM,SAAU,cAAV,CAAyB,SAAzB,EAA0C;EAC9C,eAAe,CAAC,SAAD,EAAY,gBAAZ,CAAf;EACA,IAAM,cAAc,GAAG,IAAI,CAAC,KAAL,CAAW,SAAX,CAAvB;;EACA,IAAI,OAAJ,EAAa;IACX,IAAI,CAAC,MAAM,CAAC,kBAAR,IAA8B,MAAM,CAAC,aAAzC,EAAwD;MAEtD,IAAM,KAAK,GAAG,IAAI,UAAJ,CAAe,cAAf,CAAd;;MACA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,cAApB,EAAoC,CAAC,EAArC,EAAyC;QACvC,KAAK,CAAC,CAAD,CAAL,GAAW,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,MAAL,KAAgB,GAA3B,CAAX;MACD;;MACD,OAAO,KAAP;IACD;EACF;;EACD,IAAI,UAAU,CAAC,cAAf,EAA+B;IAC7B,OAAO,UAAU,CAAC,cAAX,CAA0B,cAA1B,CAAP;EACD,CAFD,MAEO,IAAI,UAAU,CAAC,qBAAf,EAAsC;IAC3C,IAAM,MAAM,GAAG,UAAU,CAAC,qBAAX,CAAiC,cAAjC,CAAf;IACA,OAAO,WAAW,CAAC,MAAD,CAAlB;EACD,CAHM,MAGA;IACL,MAAM,IAAI,mBAAJ,CAAwB,aAAxB,EAAuC,gBAAvC,CAAN;EACD;AACF;AASD,OAAO,SAAe,mBAAf,CAAmC,SAAnC;EAAA;EAAA;IAAA;MAAA;QAAA;UACL,eAAe,CAAC,SAAD,EAAY,qBAAZ,CAAf;UACM,cAFD,GAEkB,IAAI,CAAC,KAAL,CAAW,SAAX,CAFlB;;UAAA,KAGD,UAAU,CAAC,mBAHV;YAAA;YAAA;UAAA;;UAAA;UAAA,iCAIU,UAAU,CAAC,mBAAX,CAA+B,cAA/B,CAJV;;QAAA;UAAA;;QAAA;UAAA,KAKM,UAAU,CAAC,0BALjB;YAAA;YAAA;UAAA;;UAAA;UAAA,iCAMkB,UAAU,CAAC,0BAAX,CAAsC,cAAtC,CANlB;;QAAA;UAMG,MANH;UAAA,iCAOI,WAAW,CAAC,MAAD,CAPf;;QAAA;UAAA,MASG,IAAI,mBAAJ,CAAwB,aAAxB,EAAuC,qBAAvC,CATH;;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA;AAAA","sourcesContent":["import { toByteArray } from 'base64-js';\nimport { UnavailabilityError } from 'expo-modules-core';\n\nimport ExpoRandom from './ExpoRandom';\n\nfunction assertByteCount(value: any, methodName: string): void {\n  if (\n    typeof value !== 'number' ||\n    isNaN(value) ||\n    Math.floor(value) < 0 ||\n    Math.floor(value) > 1024\n  ) {\n    throw new TypeError(\n      `expo-random: ${methodName}(${value}) expected a valid number from range 0...1024`\n    );\n  }\n}\n\n// @needsAudit\n/**\n * Generates completely random bytes using native implementations. The `byteCount` property\n * is a `number` indicating the number of bytes to generate in the form of a `Uint8Array`.\n * Falls back to `Math.random` during development to prevent issues with React Native Debugger.\n * @param byteCount - A number within the range from `0` to `1024`. Anything else will throw a `TypeError`.\n * @return An array of random bytes with the same length as the `byteCount`.\n */\nexport function getRandomBytes(byteCount: number): Uint8Array {\n  assertByteCount(byteCount, 'getRandomBytes');\n  const validByteCount = Math.floor(byteCount);\n  if (__DEV__) {\n    if (!global.nativeCallSyncHook || global.__REMOTEDEV__) {\n      // remote javascript debugging is enabled\n      const array = new Uint8Array(validByteCount);\n      for (let i = 0; i < validByteCount; i++) {\n        array[i] = Math.floor(Math.random() * 256);\n      }\n      return array;\n    }\n  }\n  if (ExpoRandom.getRandomBytes) {\n    return ExpoRandom.getRandomBytes(validByteCount);\n  } else if (ExpoRandom.getRandomBase64String) {\n    const base64 = ExpoRandom.getRandomBase64String(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-random', 'getRandomBytes');\n  }\n}\n\n// @needsAudit\n/**\n * Generates completely random bytes using native implementations. The `byteCount` property\n * is a `number` indicating the number of bytes to generate in the form of a `Uint8Array`.\n * @param byteCount - A number within the range from `0` to `1024`. Anything else will throw a `TypeError`.\n * @return A promise that fulfills with an array of random bytes with the same length as the `byteCount`.\n */\nexport async function getRandomBytesAsync(byteCount: number): Promise<Uint8Array> {\n  assertByteCount(byteCount, 'getRandomBytesAsync');\n  const validByteCount = Math.floor(byteCount);\n  if (ExpoRandom.getRandomBytesAsync) {\n    return await ExpoRandom.getRandomBytesAsync(validByteCount);\n  } else if (ExpoRandom.getRandomBase64StringAsync) {\n    const base64 = await ExpoRandom.getRandomBase64StringAsync(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-random', 'getRandomBytesAsync');\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}